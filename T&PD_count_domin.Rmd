---
title: Count Regression Model Dominance Analysis
subtitle: Documentation
author: Joseph Luchman
output: html_notebook
editor_options: 
  markdown: 
    wrap: 72
---

Documentation begins with setting the R environment.

A component of this environment is the random seed to reproduce the data.

```{r set-up, results='hide'}
library(gt)
library(knitr)
library(kableExtra)
library(MASS)
library(pscl)
library(tidyverse)
library(magrittr)
library(domir)
library(performance)
library(parameters)
library(datawizard)
library(MCMCpack)

set.seed(84490856)
```

# Data Generation

This section describes the data generation component of the count dominance analysis manuscript.

## Generate IV matrix

Data generation is founded on the initial covariance matrix on which all subsequent data is based.

The covariance matrix developed for use in this manuscript is reported on below.  



```{r gen-iv-mat}
# Covariance_Matrix <- 
#   c(1, .5^(1:3)*sqrt(1*c(1.8, 2.8, 4))*sqrt(1), 
#     .5*sqrt(1)*sqrt(1*1.8), 1.8, .5^(3:2)*sqrt(1*1.8)*sqrt(1*c(2.8, 4)), 
#     .5^(2:3)*sqrt(1*2.8)*sqrt(1*c(1, 1.8)), 2.8, .5*sqrt(1*2.8)*sqrt(1*4), 
#     .5^(3:1)*sqrt(1*4)*sqrt(1*c(1, 1.8, 2.8)), 4) |> 
#   matrix(nrow=4, byrow = TRUE)

Covariance_Matrix <- 
  c(1, .5^(1:3)*sqrt(1*c(1.8, 2.8, 4))*sqrt(1),
    .5*sqrt(1)*sqrt(1*1.8), 1.8, .5^(3:2)*sqrt(1*1.8)*sqrt(1*c(2.8, 4)),
    .5^(2:3)*sqrt(1*2.8)*sqrt(1*c(1, 1.8)), 2.8, .5*sqrt(1*2.8)*sqrt(1*4),
    .5^(3:1)*sqrt(1*4)*sqrt(1*c(1, 1.8, 2.8)), 4) |>
  matrix(nrow=4, byrow = TRUE)

Covariance_Matrix %>% kable()

Covariance_Matrix %>% cov2cor() %>% kable()
```

The covariance matrix developed doesn't 'feel' like real data.  As such, instead of using it directly, it is used as a parameter in a random draw from an inverse Wishart distribution.

```{r sample-iv-mat}
Covariance_Matrix_Use <- 
  riwish(5, Covariance_Matrix)

Covariance_Matrix_Use %>% kable()

Covariance_Matrix_Use %>% cov2cor() %>% kable()
```

The section below produces the combined correlation matrix tables for display in the manuscript.

```{r}
Covariance_Matrix %>% 
  as.data.frame %>%
  set_names(str_c("IV", 1:4)) %>%
  bind_cols(tibble(name = str_c("IV",1:4))) %>%
  bind_rows(
    Covariance_Matrix_Use %>% as.data.frame() %>% 
      set_names(str_c("IV", 1:4)) %>%
      bind_cols(tibble(name = str_c("IV",1:4)))
  ) %>%
  gt(rowname_col = "name") %>%
  # tab_style(
  #   style = 
  #     cell_borders(sides = "bottom"),
  #   locations = cells_body(rows = 4)
  # ) %>%
  tab_row_group(label = "Sampled", rows = 5:8) %>% 
  tab_row_group(label = "Parameter", rows = 1:4) %T>%
  print %>%
  gtsave(filename = "corrs.tex", path = "./includes/")


```

## Generate IV Data

```{r gen-iv-data}
Data_Frame <- 
  mvrnorm(n = 100000, 
          mu = rep(0, times = 4), 
          Sigma = Covariance_Matrix_Use) %>% 
  as.data.frame() %>%
  rename_with(~ str_c("I", .))

Data_Frame %>%
  summarise(
    across(.fns = mean),
    ) 

Data_Frame %>%
  summarise(
    across(.fns = sd),
    ) 

Data_Frame %>% 
  cor %>% 
  kable
```

## Generate Normal Gaussian Dependent Variable

```{r gen-y-normal}
Coefficient_Vector <- 
  rnorm(4, 0, .2)

Coefficient_Vector %>% kable

Data_Frame %<>%
  mutate(
    Y_Normal = 
      IV1*Coefficient_Vector[[1]] + IV2*Coefficient_Vector[[2]] + 
      IV3*Coefficient_Vector[[3]] + IV4*Coefficient_Vector[[4]], 
    Y_Normal = Y_Normal + rnorm(100000, 0, sqrt(1 - var(Y_Normal)))
  )

Data_Frame %>%
  summarise(
    across(.fns = mean),
    ) 

Data_Frame %>%
  summarise(
    across(.fns = sd),
    ) 

Data_Frame %>% 
  cor %>% 
  kable
```

## Generate Poisson Dependent Variable

```{r gen-y-poisson}
Data_Frame %<>%
  mutate(
    Y_Poisson = qpois(pnorm(Y_Normal, log.p = TRUE), 1, log.p = TRUE)
  )

Data_Frame %>%
  summarise(
    across(.fns = mean),
    ) 

Data_Frame %>%
  summarise(
    across(.fns = sd),
    ) 

Data_Frame %>% 
  cor %>% 
  kable
```

## Generate Negative Binomial Dependent Variable

```{r gen-y-neg-bin}
Data_Frame %<>%
  mutate(
    Y_NegativeBinomial = qnbinom(pnorm(Y_Normal, log.p = TRUE), size = .5, mu = 1, log.p = TRUE),
  )

```

## Offset

Work with Poisson and assume $np = \lambda$ or $10*.1 = 1$

Sample 1 to the full 10 of obs.

```{r}

Offset_Vector <- 
  rnorm(4, 0, .2)

Offset_Vector %>% kable

Data_Frame %<>%
  mutate(
    Number_Observed = sample(1:10, 100000, replace = TRUE),
    Censoring =
      IV1*Offset_Vector[[1]] + IV2*Offset_Vector[[2]] + 
      IV3*Offset_Vector[[3]] + IV4*Offset_Vector[[4]],
    Censoring = Censoring + rnorm(100000, 0, sqrt(1 - var(Censoring)))
  )

Data_Frame %>% select(Number_Observed) %>% 
  ggplot(aes(Number_Observed)) + stat_bin()

Data_Frame %<>%
  mutate(
    Y_Poisson_Offset = 
      qbinom(
        pnorm(Y_Normal, log.p = TRUE),
             Number_Observed, .1, log.p = TRUE
        )
  )

Data_Frame %>%
  select(Y_Poisson_Offset) %>%
  ggplot(aes(Y_Poisson_Offset)) + stat_bin()

Data_Frame %<>%
  mutate(
    N_obs_censor =
      qunif(
        pnorm(Censoring, log.p = TRUE), 
        1, 10, log.p = TRUE) %>% ceiling(),
    Y_Poisson_Censored = 
      qbinom(
        pnorm(Y_Normal, log.p = TRUE),
             N_obs_censor, .1, log.p = TRUE
        )
  )

Data_Frame %>% select(N_obs_censor) %>% 
  ggplot(aes(N_obs_censor)) + stat_bin()

Data_Frame %>%
  select(Y_Poisson_Censored) %>%
  ggplot(aes(Y_Poisson_Censored)) + stat_bin()

```

## Zero-inflated


```{r}
Data_Frame %<>%
  mutate(
    Y_ZIP = 
      Y_Poisson * 
      qbinom(
        pnorm(Censoring, log.p = TRUE),
        1, .9, log.p = TRUE)
  )

Data_Frame %>%
  select(Y_ZIP) %>%
  ggplot(aes(Y_ZIP)) + stat_bin()
```

# Primary Modeling

## Linear Regressions

```{r lm-results}
lm_result <- 
  lm(Y_Normal ~ IV1 + IV2 + IV3 + IV4, data = Data_Frame) 

lm_result %>% parameters()

lm_result %>% standardise_parameters(method = "basic")

lm_result %>%
  dominance_analysis()
```



```{r all-subsets-lm}
lm_capture <- 
  function(formula, ...) { # wrapper program that accepts formula and ellipsis arguments
    count <<- count + 1 # increment counter in enclosing environment
    lm_obj <- lm(formula, ...) # estimate 'lm' model and save object
    DA_lm_results[count, "formula"] <<- 
      deparse(formula) # record string version of formula passed in 'DA_results' in enclosing environment
    DA_lm_results[count, "R^2"] <<- 
      summary(lm_obj)[["r.squared"]] # record R^2 in 'DA_results' in enclosing environment
    return(lm_obj) # return 'lm' class-ed object
  }

count <- 0 # initialize the count indicating the row in which the results will fill-in

DA_lm_results <- # container data frame in which to record results
  data.frame(formula = rep("", times = 2^3-1), 
             `R^2` = rep(NA, times = 2^3-1), 
             check.names = FALSE)

lm_da <- domin(Y_Normal ~ IV1 + IV2 + IV3 + IV4, # implement the DA with the wrapper
               lm_capture, 
               list(summary, "r.squared"), 
               data = Data_Frame)

DA_lm_results
```

## Poisson Regressions

```{r poisson-result}
poisson_result <- 
  glm(Y_Poisson ~ IV1 + IV2 + IV3 + IV4, data = Data_Frame, family = poisson()) 

poisson_result %>% 
  parameters()

poisson_result %>%
  standardise_parameters(method = "basic")

poisson_result %>%
  dominance_analysis()

```

```{r poisson-all-subsets}
ps_capture <- 
  function(formula, ...) { # wrapper program that accepts formula and ellipsis arguments
    count <<- count + 1 # increment counter in enclosing environment
    ps_obj <- glm(formula, ...) # estimate 'glm' model and save object
    DA_ps_results[count, "formula"] <<- 
      deparse(formula) # record string version of formula passed in 'DA_results' in enclosing environment
    DA_ps_results[count, "R^2"] <<- 
      r2(ps_obj)[["R2_Nagelkerke"]] # record R^2 in 'DA_results' in enclosing environment
    return(ps_obj) # return 'lm' class-ed object
  }

count <- 0 # initialize the count indicating the row in which the results will fill-in

DA_ps_results <- # container data frame in which to record results
  data.frame(formula = rep("", times = 2^3-1), 
             `R^2` = rep(NA, times = 2^3-1), 
             check.names = FALSE)

ps_da <- domin(Y_Poisson ~ IV1 + IV2 + IV3 + IV4, # implement the DA with the wrapper
               ps_capture, 
               list(r2, "R2_Nagelkerke"), 
               data = Data_Frame, family = poisson())

DA_ps_results
```

## Negative Binomial Regressions

```{r NB-result}
nb_result <- 
  glm.nb(Y_NegativeBinomial ~ IV1 + IV2 + IV3 + IV4, data = Data_Frame) 

nb_result %>% 
  parameters()

nb_result %>%
  standardise_parameters(method = "basic")

# ~~~ NB regs don't work with dominance_analysis() - method dispatch issue?
# ~~~ they have r2() method but DA doesn't recognze it
# nb_result %>%
#   dominance_analysis()
domir(Y_NegativeBinomial ~ IV1 + IV2 + IV3 + IV4, 
      \(fml,...) {
        res <- glm.nb(fml, ...) 
        ret <- r2(res)[[1]]
      }
      ,
      data = Data_Frame) 
```



```{r NB-all-subsets}
nb_capture <- 
  function(formula, ...) { # wrapper program that accepts formula and ellipsis arguments
    count <<- count + 1 # increment counter in enclosing environment
    nb_obj <- glm.nb(formula, ...) # estimate 'glm' model and save object
    DA_nb_results[count, "formula"] <<- 
      deparse(formula) # record string version of formula passed in 'DA_results' in enclosing environment
    DA_nb_results[count, "R^2"] <<- 
      r2(nb_obj)[["R2_Nagelkerke"]] # record R^2 in 'DA_results' in enclosing environment
    return(nb_obj) # return 'lm' class-ed object
  }

count <- 0 # initialize the count indicating the row in which the results will fill-in

DA_nb_results <- # container data frame in which to record results
  data.frame(formula = rep("", times = 2^3-1), 
             `R^2` = rep(NA, times = 2^3-1), 
             check.names = FALSE)

nb_da <- domin(Y_NegativeBinomial ~ IV1 + IV2 + IV3 + IV4, # implement the DA with the wrapper
               nb_capture, 
               list(r2, "R2_Nagelkerke"), 
               data = Data_Frame)

DA_nb_results
```


# Offset Modeling

## Wrong Poisson

```{r}
poisson_result_offset_wrong <- 
  glm(Y_Poisson_Offset ~ IV1 + IV2 + IV3 + IV4, data = Data_Frame, 
      family = poisson())

poisson_result_offset_wrong %>% 
  parameters()

poisson_result_offset_wrong %>%
  standardise_parameters(method = "basic")

domir(Y_Poisson_Offset ~ IV1 + IV2 + IV3 + IV4, 
      \(fml,...) {
        res <- glm(fml, ...) 
        ret <- r2(res)[[1]]
      }
      ,
      data = Data_Frame, family = poisson()) 
```

## Right Poisson

```{r}
poisson_result_offset_right <- 
  glm(Y_Poisson_Offset ~IV1 + IV2 + IV3 + IV4 + offset(log(Number_Observed)), data = Data_Frame, 
      family = poisson())

poisson_result_offset_right %>% 
  parameters()

poisson_result_offset_right %>%
  standardise_parameters(method = "basic")

domir(Y_Poisson_Offset ~ IV1 + IV2 + IV3 + IV4, 
      \(fml,...) {
        fml2 <- update(fml, . ~ . + offset(log(Number_Observed)))
        res <- glm(fml2, ...) 
        ret <- r2(res)[[1]]
      }
      ,
      data = Data_Frame, family = poisson()) 
```



## Wrong Poisson C

```{r}
poisson_result_cens_wrong <- 
  glm(Y_Poisson_Censored ~ IV1 + IV2 + IV3 + IV4, data = Data_Frame, 
      family = poisson())

poisson_result_cens_wrong %>% 
  parameters()

poisson_result_cens_wrong %>%
  standardise_parameters(method = "basic")

domir(Y_Poisson_Censored ~ IV1 + IV2 + IV3 + IV4, 
      \(fml,...) {
        res <- glm(fml, ...) 
        ret <- r2(res)[[1]]
      }
      ,
      data = Data_Frame, family = poisson()) 
```

## Right Poisson C

```{r}
poisson_result_cens_right <- 
  glm(Y_Poisson_Censored ~IV1 + IV2 + IV3 + IV4 + offset(log(N_obs_censor)), data = Data_Frame, 
      family = poisson())

poisson_result_cens_right %>% 
  parameters()

poisson_result_cens_right %>%
  standardise_parameters(method = "basic")

domir(Y_Poisson_Censored ~ IV1 + IV2 + IV3 + IV4, 
      \(fml,...) {
        fml2 <- update(fml, . ~ . + offset(log(N_obs_censor)))
        res <- glm(fml2, ...) 
        ret <- r2(res)[[1]]
      }
      ,
      data = Data_Frame, family = poisson()) 
```

# Zero-Inflation

```{r}
zip_result <- 
  zeroinfl(Y_ZIP ~ IV1 + IV2 + IV3 + IV4 | IV1 + IV2 + IV3 + IV4, 
           data = Data_Frame)

zip_result %>% 
  parameters()

zip_result %>%
  standardise_parameters(method = "basic")
```

## IV DA

```{r}
domir(Y_ZIP ~ IV1 + IV2 + IV3 + IV4, 
      \(fml,...) {
        fml2 <- update(fml, . ~ .)
        res <- zeroinfl(fml2, ...) 
        ret <- r2(res)[[1]]
      }
      ,
      data = Data_Frame) 
```

# Records and Reproducibility

```{r}
sessionInfo()
```

The random seed information used in this session:

    84490856
    Min: 1, Max: 99999999
    2022-08-14 14:50:02 UTC
    Random.org
